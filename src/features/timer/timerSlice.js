import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
import { fetchCount } from './counterAPI'

const initialState = {
  value: 10,
  status: 'idle',
  hour: 1,
  minute: 0,
  second: 5,
  runTimer: false,
  Q_id: 1,
  answer: "",
  login: false,
  data: {}
}

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const incrementAsync = createAsyncThunk(
  'counter/fetchCount',
  async amount => {
    const response = await fetchCount(amount)
    // The value we return becomes the `fulfilled` action payload
    return response.data
  }
)

export const timerSlice = createSlice({
  name: 'timer',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    increment: state => {
      state.value += 1
    },
    incrementSecond: state => {
      state.second += 59
    },
    incrementMinute: state => {
      state.minute += 59
    },
    decrementHour: state => {
      state.hour -= 1
    },
    decrementMinute: state => {
      state.minute -= 1
    },
    decrementSecond: state => {
      state.second -= 1
    },
    setTimer: state => {
      state.runTimer = true
    },
    stopTimer: state => {
      state.runTimer = false
      state.Q_id = 1
      state.hour = initialState.hour
      state.minute = initialState.minute
      state.second = initialState.second
    },
    nextQ: state => {
      state.Q_id += 1
      state.answer = ""
    },
    prevQ: state => {
      state.Q_id -= 1
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementByAmount: (state, action) => {
      state.value += action.payload
    },
    setLogin: state => {
      state.login = true
    },
    setLogout: state => {
      state.login = false
    },
    setData: (state, action) => {
      state.data = action.payload
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {
    builder
      .addCase(incrementAsync.pending, state => {
        state.status = 'loading'
      })
      .addCase(incrementAsync.fulfilled, (state, action) => {
        state.status = 'idle'
        state.value += action.payload
      })
  }
})

export const {
  increment,
  incrementSecond,
  incrementMinute,
  decrementSecond,
  decrementHour,
  incrementByAmount,
  decrementMinute,
  stopTimer,
  setTimer,
  resetTimer,
  nextQ,
  prevQ,
  setLogin,
  setLogout,
  setData,
} = timerSlice.actions

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectCount = state => state.timer

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const incrementIfOdd = amount => (dispatch, getState) => {
  const currentValue = selectCount(getState())
  if (currentValue % 2 === 1) {
    dispatch(incrementByAmount(amount))
  }
}

export default timerSlice.reducer
